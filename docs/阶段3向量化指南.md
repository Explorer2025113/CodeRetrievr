# 阶段3：代码向量化与知识图谱构建指南

## 概述

阶段3的主要任务是将采集的代码片段：
1. 转换为向量并存储到Milvus
2. 构建知识图谱并存储到Neo4j
3. 建立两个数据库之间的关联

## 已创建的核心模块

### 1. 代码嵌入服务 (`app/services/embedding_service.py`)

**功能**：
- 使用CodeBERT模型将代码转为向量
- 支持批量编码
- 自动管理模型加载

### 2. Milvus服务 (`app/services/milvus_service.py`)

**功能**：
- 连接Milvus数据库
- 创建集合和索引
- 插入代码向量
- 相似度搜索

### 3. Neo4j服务 (`app/services/neo4j_service.py`)

**功能**：
- 连接Neo4j数据库
- 创建代码片段节点
- 创建依赖关系
- 创建语言关系
- 查询关联信息

### 4. 向量化脚本 (`scripts/vectorize_code.py`)

**功能**：
- 读取采集的JSON文件
- 批量向量化代码
- 存储到Milvus和Neo4j
- 显示处理进度

## 使用步骤

### 步骤1：确保数据库服务运行

```bash
# 检查Docker服务
docker-compose ps

# 如果未运行，启动服务
docker-compose up -d

# 验证服务
# Milvus: http://localhost:9091/healthz
# Neo4j: http://localhost:7474
```

### 步骤2：运行向量化脚本

```bash
# 激活conda环境
conda activate coderetrievr

# 向量化代码片段
python scripts/vectorize_code.py data/code_snippets/code_snippets_tiangolo_fastapi_20251110_231137.json

# 或指定批处理大小（默认100）
python scripts/vectorize_code.py data/code_snippets/your_file.json --batch-size 50
```

### 步骤3：验证结果

```bash
# 检查Milvus中的数据
python -c "from app.services.milvus_service import get_milvus_service; s = get_milvus_service(); print(s.get_collection_stats())"

# 检查Neo4j中的数据
python -c "from app.services.neo4j_service import get_neo4j_service; s = get_neo4j_service(); print(s.get_statistics())"
```

## 处理流程

```
1. 加载JSON文件
   ↓
2. 分批处理代码片段
   ↓
3. 使用CodeBERT编码为向量
   ↓
4. 插入Milvus（向量 + 元数据）
   ↓
5. 插入Neo4j（节点 + 关系）
   ↓
6. 建立Milvus ID和Neo4j code_id的映射
```

## 注意事项

### 1. 模型下载

首次运行会自动下载CodeBERT模型（约400MB），需要一些时间。

### 2. 批处理大小

- 默认：100个片段/批
- 如果内存不足，可以减小batch_size
- 如果GPU可用，可以增大batch_size

### 3. 处理时间

- 1756个片段大约需要10-20分钟
- 取决于CPU/GPU性能和网络速度（首次下载模型）

### 4. 错误处理

脚本会自动处理错误并继续处理下一批，最终会显示错误统计。

## 下一步

向量化完成后，可以：

1. **进入阶段4**：开发检索功能和AI说明生成
2. **测试检索**：验证向量搜索功能
3. **查看知识图谱**：在Neo4j浏览器中查看图谱结构

---

**文档版本**：v1.0  
**创建日期**：2024年  
**最后更新**：2024年

